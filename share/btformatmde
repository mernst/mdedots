#!/usr/bin/env perl
use strict;
use English;
$WARNING = 1;

use Text::BibTeX;
use Getopt::Tabular;

# forward declarations of subroutine prototypes.
sub unlatexify( $ );
sub format_entry( $$ );

# ----------------------------------------------------------------------
# Command-line options and option table

my @select;                             # list of citation keys
my $markup = 'latex';
# my $markup = 'html';
my $open_bib = 0;

my @opt_table =
   (['-select', 'call', undef, sub { &get_list_arg (@_, \@select) },
     'list of entries to format (selected by citation key)',
     'key1 ...'],
    ['-latex', 'const', 'latex', \$markup,
     'add LaTeX 2.09 markup to the bibliography entries'],
    ['-latex2e', 'const', 'latex2e', \$markup,
     'add LaTeX 2e markup to the bibliography entries'],
    ['-html', 'const', 'html', \$markup,
     'add HTML markup to the bibliography entries'],
    ['-openbib|-closedbib', 'boolean', 0, \$open_bib,
     'use "open" bibliography format'],
   );



# ----------------------------------------------------------------------
# Main program

my $usage = "usage: btformat [options] bibfile ...\n";
Getopt::Tabular::SetHelp ($usage, undef);
GetOptions (\@opt_table, \@ARGV) || exit 1;

## This must come after "GetOptions", blech.

# Default markups -- should be customizable
my %markup =
   (pre_entry => { latex => '\bibitem{%KEY%}' . "\n",
                   latex2e => '\bibitem{%KEY%}' . "\n",
                   # html => '"[%LABEL%]"'
                   html => '' },
    inter_block => { latex => "\n\\newblock ",
                     latex2e => "\n\\newblock ",
                     html => $open_bib ? "<br>\n" : "\n" },
    atitle => { latex => ['{\em ', '}'],
                latex2e => ['\emph{', '}'],
                html => ['<em>', '</em>'] },
    btitle => { latex => ['{\em ', '}'],
                latex2e => ['\emph{', '}'],
                html => ['<em>', '</em>'] },
    journal => { latex => ['{\em ', '}'],
                 latex2e => ['\emph{', '}'],
                 html => ['<em>', '</em>'] },
    tie => { latex => '~',
	     latex2e => '~',
	     html => '&nbsp;' },
   );



# OK, we're happy with the command-line -- let's start working for real

my (%sortkey, @entries, %select);

# If any file doesn't contain at least one BibTeX entry, btool dies with:
#   fatal error: bt_parse_entry: you can't interleave calls across different files
while (scalar(@ARGV) > 0) {
   my $filename = shift;
   my $bibfile = new Text::BibTeX::File($filename) or die "$filename: $!\n";
   $bibfile->set_structure ('Bib', namestyle => 'full', nameorder => 'first',
			    atitle_mkup => $markup{atitle}{$markup},
			    btitle_mkup => $markup{btitle}{$markup},
			    journal_mkup => $markup{journal}{$markup},
			    tie_mkup => $markup{tie}{$markup},
			    sortby => 'year',
			    );


   %select = map { ($_ => 1) } @select
      if @select;

   my $entry;
   while ($entry = new Text::BibTeX::Entry $bibfile)
   {
      next unless $entry->parse_ok && $entry->metatype == BTE_REGULAR;
      $entry->check;
      $sortkey{$entry} = $entry->sort_key;
      push (@entries, $entry);
   }
   $bibfile->close;
}

sub author_ernst ( $ ) {
  my ($ae_entry) = @_;
  my $omitfromcv = $ae_entry->get('omitfromcv');
  if (defined($omitfromcv) && $omitfromcv) {
    return 0;
  }
  my $author = $ae_entry->get('author');
  my $editor = $ae_entry->get('editor');
  return ((defined($author) && $author =~ /Michael/ && $author =~ /Ernst/)
	  || (defined($editor) && $editor =~ /Michael/ && $editor =~ /Ernst/));
}

# strip entries not by me
@entries = grep { author_ernst($_) } @entries;

# for my $this_entry (@entries) {
#   print "sortkey = $sortkey{$this_entry}\n";
# }

@entries = sort { -($sortkey{$a} cmp $sortkey{$b}) } @entries;

my $pubsdir = "/g2/users/mernst/public_html/pubs-new";
# filestolink is a list of papers (eg, .ps and .pdf files) in the current
# directory; every one of them should be hyperlinked to from somewhere, and
# we keep track of that.
my @filestolink;
my @linkedfiles = ();		# files that were actually hyperlinked to
{ # set filestolink
  opendir(DIR, $pubsdir) || die "can't opendir $pubsdir: $!";
  @filestolink = grep { ! (/\.html/ || /^TAGS$/ || /^\./) } readdir(DIR);
  closedir DIR;
}

while (my $entry = shift @entries)
{
   next unless $entry->parse_ok && $entry->metatype == BTE_REGULAR;
   next if (@select && ! $select{$entry->key});

#      printf "formatting entry >%s<\n", $entry->key;

   my $f_entry = format_entry($entry, 1);

   if (defined($f_entry))
   {
      my $key = $entry->key;
      my $header = $markup{pre_entry}{$markup};
      $header =~ s/%KEY%/$key/g;
      $header = "<p>\n";

      print $header;
      print $f_entry;

      my $basefilename = $entry->get('basefilename');
      if (!defined($basefilename)) {
	if (! $entry->get('supersededby')) {
	  print STDERR "No basefilename for ", $entry->get('title'), "\n";
	}
      } elsif ($basefilename eq "") {
	# not available online
      } else {
	print "<br>\n";
	print "<a href=\"$basefilename-abstract.html\">Abstract</a>.\n";
	my @downloadparts = ();
	{
	  my @printparts = ();
	  if (-f "$pubsdir/$basefilename.ps") {
	    push @printparts, "<a href=\"$basefilename.ps\">PostScript</a>";
	    push @linkedfiles, "$basefilename.ps";
	  }
	  if (-f "$pubsdir/$basefilename.ps.gz") {
	    push @printparts, "<a href=\"$basefilename.ps.gz\">gzipped PostScript</a>";
	    push @linkedfiles, "$basefilename.ps.gz";
	  }
	  if (-f "$pubsdir/$basefilename.pdf") {
	    push @printparts, "<a href=\"$basefilename.pdf\">PDF</a>";
	    push @linkedfiles, "$basefilename.pdf";
	  }
	  if (scalar(@printparts) > 0) {
	    push @downloadparts, join(",\n", @printparts);
	  }
	}
	## Add other downloadparts here
	if (scalar(@downloadparts) > 0) {
	  print "Download:\n", join(";\n", @downloadparts), ".\n";
	}
      }

      print "\n\n";
   }
}

my %unlinked = ();
for my $f (@filestolink) { $unlinked{$f} = 1; }
for my $f (@linkedfiles) { delete $unlinked{$f}; }
for my $f (sort keys %unlinked) {
  print STDERR "File $f was never linked to.\n";
}


###########################################################################
### Subroutines
###

# Return a list of blocks with formatting done.
sub format_blocks {
   my @blocks = @_;

   @blocks = grep ($_, @blocks);        # strip empty blocks

   BLOCK:
   for my $block (@blocks)
   {
      # This test is necessary because the "Note" field is returned as text,
      # not as a reference.
      if (ref($block)) {
	 SENTENCE:
	 for my $sentence (@$block)
	 {
	    if (! defined($sentence)) { $sentence = ''; next SENTENCE; }

	    # If sentence has multiple clauses, process them: first, strip
	    # out empties, and jump to the next sentence if it turns out
	    # this one is empty (ie. just a bunch of empty clauses).  Then
	    # join the left-over clauses with commas.
	    if (ref $sentence eq 'ARRAY')
	    {
	       @$sentence = grep ($_, @$sentence);
	       ($sentence = '', next SENTENCE) unless @$sentence;
	       $sentence = join (', ', @$sentence);
	    }

	    if (defined($sentence)) {
	       # finish sentence with a period if it's not already punctuated
	       $sentence .= '.' unless $sentence eq '' || $sentence =~ /[.!?]$/;
	    }
	 }

	 # Now join together all the sentences in the block, first stripping
	 # any empties.
	 @$block = grep ($_, @$block);
	 if (scalar(@$block) > 0) {
	    $block = join (' ', @$block);     # put the sentences together
	 } else {
	    $block = "";	# set to empty; will be stripped later
	 }
      } else {
	 $block .= '.' unless $block eq '' || $block =~ /[.!?]$/;
      }
   }

   @blocks = grep ($_, @blocks);        # strip empty blocks
}

# Modify the argument by side effect to eliminate some LaTeXisms.
sub unlatexify ( $ ) {
   my ($text) = @_;

   $text =~ s/-(-[0-9])/$1/g; # "--" => "-"
   $text =~ s/~([0-9\\])/ $1/g; # "~" => " "
   $text =~ s/([A-Z]\.)~/$1 /g; # "~" => " "
   $text =~ s/{([-A-Za-z]+)}/$1/g; # remove "{...}"
   $text =~ s/(?:\{|\\bgroup)\\em ([^{}]+)(?:\}|\\egroup)/<em>$1<\/em>/g; # "\em" => "<em>"

   return $text;
 }

sub format_entry ( $$ ) {
   my ($entry, $title_first) = @_;

   my @blocks = $entry->format;
   @blocks = format_blocks(@blocks);

   if (@blocks)
   {
      my $key = $entry->key;
      my $header = $markup{pre_entry}{$markup};
      $header =~ s/%KEY%/$key/g;
      $header = "<p>\n";

      if ($title_first) {
	# Swap title and author (put title first).
	my $authors = $blocks[0];
	$blocks[0] = "<b>$blocks[1]</b>";
	$blocks[1] = $authors;
      }

      my $f_entry = join ($markup{inter_block}{$markup}, @blocks);

      # $f_entry = unlatexify($f_entry);

      return $f_entry;
   }
   return undef;
}

